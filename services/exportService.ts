import { Item, CategoryEnum } from "../types";

// Helper to access JSZip from CDN
declare const JSZip: any;

const getFileExtension = (item: Item): string => {
  if (item.category === CategoryEnum.PROMPT) return '.md';
  if (item.category === CategoryEnum.NOTE) return '.md';
  if (item.category === CategoryEnum.REGISTRY) return '.reg';
  
  // Code mapping
  const lang = item.language?.toLowerCase() || '';
  const map: Record<string, string> = {
    'typescript': '.ts',
    'javascript': '.js',
    'python': '.py',
    'html': '.html',
    'css': '.css',
    'json': '.json',
    'bash': '.sh',
    'sql': '.sql',
    'powershell': '.ps1',
    'java': '.java',
    'csharp': '.cs',
    'cpp': '.cpp'
  };
  return map[lang] || '.txt';
};

const sanitizeFilename = (name: string): string => {
  return name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
};

export const downloadFile = (content: string | Blob, filename: string, mimeType: string = 'text/plain') => {
  const blob = content instanceof Blob ? content : new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

export const downloadSingleItem = (item: Item) => {
  const ext = getFileExtension(item);
  const filename = `${sanitizeFilename(item.title)}${ext}`;
  
  let content = item.content;
  
  // Format .reg content if it's a single registry item download (generic)
  // Although usually Registry items go through generateRegFile which groups them.
  // This fallback ensures individual registry download is valid format.
  if (item.category === CategoryEnum.REGISTRY && !content.startsWith('Windows Registry')) {
     const value = item.registryType === 'REG_DWORD' 
        ? `dword:${parseInt(item.content).toString(16).padStart(8, '0')}` 
        : `"${item.content.replace(/"/g, '\\"')}"`;
     const name = item.title === '(Default)' || item.title === '@' ? '@' : `"${item.title}"`;
     content = `Windows Registry Editor Version 5.00\n\n[${item.registryPath}]\n${name}=${value}`;
  }

  downloadFile(content, filename, 'text/plain');
};

export const generateZipArchive = async (items: Item[]) => {
  if (typeof JSZip === 'undefined') {
    alert("Erreur: Librairie JSZip non chargée.");
    return;
  }

  const zip = new JSZip();

  items.forEach(item => {
    const ext = getFileExtension(item);
    let filename = `${sanitizeFilename(item.title)}${ext}`;
    
    // Ensure unique filenames in zip
    let counter = 1;
    while(zip.file(filename)) {
        filename = `${sanitizeFilename(item.title)}_${counter}${ext}`;
        counter++;
    }

    let content = item.content;
    
    // Format Registry items inside zip properly
    if (item.category === CategoryEnum.REGISTRY) {
       const value = item.registryType === 'REG_DWORD' 
        ? `dword:${parseInt(item.content).toString(16).padStart(8, '0')}` 
        : `"${item.content.replace(/"/g, '\\"')}"`;
       const name = item.title === '(Default)' || item.title === '@' ? '@' : `"${item.title}"`;
       content = `Windows Registry Editor Version 5.00\n\n[${item.registryPath}]\n${name}=${value}`;
    }

    zip.file(filename, content);
  });

  try {
    const content = await zip.generateAsync({ type: "blob" });
    downloadFile(content, "devsnippet_export.zip", "application/zip");
  } catch (e) {
    console.error("Failed to generate zip", e);
    alert("Erreur lors de la création du ZIP");
  }
};

export const generateRegFile = (items: Item[]) => {
  let content = "Windows Registry Editor Version 5.00\n\n";
  
  const grouped = items.reduce((acc, item) => {
    if (item.category !== CategoryEnum.REGISTRY || !item.registryPath) return acc;
    if (!acc[item.registryPath]) acc[item.registryPath] = [];
    acc[item.registryPath].push(item);
    return acc;
  }, {} as Record<string, Item[]>);

  for (const [path, groupItems] of Object.entries(grouped)) {
    content += `[${path}]\n`;
    groupItems.forEach(item => {
      let value = "";
      if (item.registryType === 'REG_DWORD') {
        const hex = parseInt(item.content).toString(16).padStart(8, '0');
        value = `dword:${hex}`;
      } else if (item.registryType === 'REG_SZ') {
        value = `"${item.content.replace(/"/g, '\\"')}"`;
      } else {
        value = `"${item.content}"`;
      }
      
      const name = item.title === '(Default)' || item.title === '@' ? '@' : `"${item.title}"`;
      content += `${name}=${value}\n`;
    });
    content += "\n";
  }

  downloadFile(content, 'export_registry.reg', 'text/plain');
};

export const generatePs1File = (items: Item[]) => {
  let content = "# Generated by DevSnippet Manager\n\n";
  
  items.forEach(item => {
    if (item.category !== CategoryEnum.REGISTRY || !item.registryPath) return;

    let type = "String";
    if (item.registryType === 'REG_DWORD') type = "DWord";
    if (item.registryType === 'REG_QWORD') type = "QWord";
    if (item.registryType === 'REG_BINARY') type = "Binary";
    if (item.registryType === 'REG_MULTI_SZ') type = "MultiString";
    if (item.registryType === 'REG_EXPAND_SZ') type = "ExpandString";

    const path = item.registryPath
      .replace('HKEY_LOCAL_MACHINE', 'HKLM:')
      .replace('HKEY_CURRENT_USER', 'HKCU:')
      .replace('HKEY_CLASSES_ROOT', 'HKCR:')
      .replace('HKEY_USERS', 'HKU:')
      .replace('HKEY_CURRENT_CONFIG', 'HKCC:');

    content += `# ${item.description || item.title}\n`;
    content += `if (!(Test-Path "${path}")) { New-Item -Path "${path}" -Force | Out-Null }\n`;
    content += `Set-ItemProperty -Path "${path}" -Name "${item.title}" -Value "${item.content}" -Type ${type} -Force\n\n`;
  });

  downloadFile(content, 'export_registry.ps1', 'text/plain');
};

export const generateBatFile = (items: Item[]) => {
  let content = "@echo off\nREM Generated by DevSnippet Manager\n\n";

  items.forEach(item => {
    if (item.category !== CategoryEnum.REGISTRY || !item.registryPath) return;
    const nameSwitch = (item.title === '(Default)' || item.title === '@') ? '/ve' : `/v "${item.title}"`;
    content += `REM ${item.description || ''}\n`;
    content += `reg add "${item.registryPath}" ${nameSwitch} /t ${item.registryType} /d "${item.content}" /f\n`;
  });

  content += "\npause";
  downloadFile(content, 'export_registry.bat', 'text/plain');
};